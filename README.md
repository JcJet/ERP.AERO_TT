# ERP.AERO Test Task — Node.js Developer

> **Node.js / Express / Sequelize / JWT / MySQL**  
> Проверочное задание: реализация REST API для регистрации, аутентификации и управления файлами пользователей.

---

## Функциональность

Проект реализует минимальную ERP-подсистему, включающую:

- **Регистрация и авторизация пользователей**
  - `POST /signin` — вход в систему
  - `POST /signin/new_token` — обновление access токена по refresh-токену
  - `POST /signup` — регистрация нового пользователя (email или телефон)
  - `GET /info` — получение информации о текущем пользователе
  - `GET /logout` — завершение сессии

- **Работа с файлами**
  - `POST /file/upload` — загрузка нового файла
  - `GET /file/list` — получение списка файлов с пагинацией
  - `GET /file/:id` — получение метаданных файла
  - `DELETE /file/delete/:id` — удаление файла
  - `GET /file/download/:id` — скачивание файла
  - `PUT /file/update/:id` — замена файла

---

## Архитектура

Применена архитектура сервис-контроллер, аналогично NestJS, но на чистом Express:

```

src/
├── controllers/       # Логика HTTP-эндпоинтов
├── services/          # Бизнес-логика и работа с БД
├── middlewares/       # Middleware для авторизации и обработки ошибок
├── models/            # Sequelize ORM-модели
├── utils/             # JWT, хелперы, валидация, etc.
└── config/            # Настройки базы данных и окружения

````

- **Sequelize ORM** — для типобезопасных моделей и связей.
- **JWT (access + refresh)** — безопасная авторизация.
- **Joi DTO** — валидация входных данных.
- **Multer** — обработка файлов.
- **ESLint + JSDoc** — единый код-стайл и документация.

---

## Установка и запуск

```bash
git clone https://github.com/JcJet/ERP.AERO_TT.git
cd ERP.AERO_TT
npm install
````
Переименовать файл .env.example в .env, изменить в нем параметры подключения к бд
````
npm run dev
````


Приложение поднимется на `http://127.0.0.1:3000`.

---

## Переменные окружения (.env)

```bash
DB_HOST=localhost
DB_PORT=5432
DB_USER=postgres
DB_PASSWORD=postgres
DB_NAME=erp_aero
JWT_SECRET=supersecret
JWT_EXPIRES_IN=600s
REFRESH_EXPIRES_IN=7d
UPLOAD_DIR=uploads
```

---

## Обоснование структуры модели `User`

В техническом задании поле `id` описано как *email или номер телефона*.
В данной реализации это поле переименовано в `identifier`, а `id` используется как **внутренний автоинкрементный первичный ключ (PK)**.

Такое разделение — **осознанное архитектурное решение**, принятое во всех коммерческих системах.

| Поле           | Назначение                                                            |
| -------------- | --------------------------------------------------------------------- |
| `id`           | Внутренний числовой PK, используется во всех связях (sessions, files) |
| `identifier`   | Email или телефон, используется как логин                             |
| `passwordHash` | Хэш пароля (bcrypt)                                                   |

**Преимущества такого подхода:**

* Безопасно изменять email/телефон без нарушения связей в БД.
* ORM-совместимый PK (удобен для FK и миграций).
* Читаемый и предсказуемый код.

> Таким образом, решение следует духу ТЗ (логин по email/телефону),
> сохраняя при этом архитектурную чистоту и масштабируемость.

---

## Модели и связи

| Модель      | Описание                        | Основные поля                                    |
| ----------- | ------------------------------- | ------------------------------------------------ |
| **User**    | Пользователь системы            | id, identifier, passwordHash                     |
| **Session** | Активная сессия (refresh токен) | id(UUID), userId, refreshTokenHash, expiresAt    |
| **File**    | Загруженные файлы               | id, userId, originalName, size, path, uploadedAt |

### Связи

* `User.hasMany(Session, { as: 'sessions' })`
* `Session.belongsTo(User, { as: 'user' })`
* `User.hasMany(File, { as: 'files' })`
* `File.belongsTo(User, { as: 'user' })`

---

## Авторизация

Реализована двойная схема:

* **Access Token (JWT)** — живёт 10 минут.
* **Refresh Token (JWT)** — живёт 7 дней, хранится в БД с хэшем (`Session.refreshTokenHash`).

Проверка авторизации выполняется в `authMiddleware.js`:

```js
Authorization: Bearer <accessToken>
```

---

## DTO и валидация

Входные данные проверяются через **Joi DTO** в контроллерах (`dto/`):

* `auth.dto.js`
* `file.dto.js`

Это приближает структуру к NestJS, сохраняя строгую типизацию и чистую валидацию на уровне HTTP-слоя.

---

## Документация

Ключевые функции, сервисы и модели оформлены в формате **JSDoc**, что позволяет:

* Генерировать документацию автоматически (`npx jsdoc src -r`),
* Поддерживать единый стандарт кода.

## Используемые технологии

| Компонент         | Назначение                    |
| ----------------- | ----------------------------- |
| **Express.js**    | Web-фреймворк                 |
| **Sequelize ORM** | Работа с PostgreSQL           |
| **jsonwebtoken**  | JWT авторизация               |
| **bcryptjs**      | Хэширование паролей и токенов |
| **multer**        | Загрузка файлов               |
| **Joi**           | DTO и валидация данных        |
| **dotenv**        | Конфигурация окружения        |

---

## Примечание

> Проект выполнен с учётом лучших практик NestJS, но на чистом Express,
> с разбиением по слоям, DTO, сервисами и документированием через JSDoc.
> Логика и структура полностью соответствуют исходному ТЗ,
> но реализованы в продакшн-качестве с безопасными архитектурными улучшениями.



# Рекомендации по улучшению / продакшн-твики

* Миграции (Sequelize CLI / Umzug) вместо `sync({ alter: true })`.
* Секреты (`JWT_*_SECRET`) хранить в секретном хранилище (Vault / cloud secrets).
* HTTPS — обязательно в продакшне.
* Установить rate-limiting на аутентификацию (brute-force защита).
* CSP, Helmet middleware для безопасности (добавить `helmet`).
* Подумать над хранением файлов в object storage (S3) в проде.
* Логи и мониторинг (winston, Sentry).
* Тесты (unit + integration).
* Ограничение размера upload (multer limit) и проверка MIME/extension.
* Swagger.

